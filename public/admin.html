<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Painel de Administrador - CineVEO</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ca8a04;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        input:focus, select:focus, textarea:focus {
             box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.5);
        }
        #episodes-list::-webkit-scrollbar, #catalog-list::-webkit-scrollbar, #report-results-list::-webkit-scrollbar { width: 6px; }
        #episodes-list::-webkit-scrollbar-track, #catalog-list::-webkit-scrollbar-track, #report-results-list::-webkit-scrollbar-track { background: #1f2937; }
        #episodes-list::-webkit-scrollbar-thumb, #catalog-list::-webkit-scrollbar-thumb, #report-results-list::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 10px; }
        .report-btn.active {
            background-color: #ca8a04;
            color: #111827;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <div id="login-screen" class="min-h-screen flex items-center justify-center">
        <div class="bg-gray-800 p-8 rounded-lg shadow-xl w-full max-w-sm">
            <img src="https://i.ibb.co/s91tycz/Gemini-Generated-Image-ejjiocejjiocejji-1.png" alt="Logo CineVEO" class="w-40 mx-auto mb-6">
            <h2 class="text-2xl font-bold text-center text-white mb-6">Acesso Restrito</h2>
            <form id="login-form" class="space-y-4">
                <input id="email" type="email" placeholder="Email" class="w-full bg-gray-700 border border-gray-600 rounded-md p-3 text-white focus:outline-none focus:border-yellow-500" required>
                <input id="password" type="password" placeholder="Senha" class="w-full bg-gray-700 border border-gray-600 rounded-md p-3 text-white focus:outline-none focus:border-yellow-500" required>
                <button type="submit" class="w-full bg-yellow-500 text-gray-900 font-bold py-3 rounded-md hover:bg-yellow-600 transition-colors">Entrar</button>
            </form>
            <div class="relative flex py-5 items-center">
                <div class="flex-grow border-t border-gray-600"></div>
                <span class="flex-shrink mx-4 text-gray-400 text-sm">OU</span>
                <div class="flex-grow border-t border-gray-600"></div>
            </div>
            <button id="google-login-btn" class="w-full bg-white text-gray-800 font-semibold py-3 rounded-md hover:bg-gray-200 transition-colors flex items-center justify-center gap-2">
                <svg class="w-5 h-5" viewBox="0 0 48 48">
                    <path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"></path>
                    <path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6.02C43.51 39.88 46.98 32.93 46.98 24.55z"></path>
                    <path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"></path>
                    <path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6.02c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"></path>
                    <path fill="none" d="M0 0h48v48H0z"></path>
                </svg>
                Entrar com Google
            </button>
        </div>
    </div>

    <div id="admin-panel" class="hidden">
        <header class="bg-gray-800 shadow-md">
            <div class="container mx-auto px-4 py-4 flex justify-between items-center">
                <img src="https://i.ibb.co/s91tycz/Gemini-Generated-Image-ejjiocejjiocejji-1.png" alt="Logo CineVEO" class="w-32">
                <div>
                    <span id="user-email" class="text-sm text-gray-400 mr-4"></span>
                    <button id="logout-button" class="bg-red-600 text-white font-semibold px-4 py-2 rounded-md text-sm hover:bg-red-700 transition">Sair</button>
                </div>
            </div>
        </header>

        <main class="container mx-auto p-4 md:p-8">
            <h1 class="text-3xl font-bold text-white mb-8">Gerenciador de Conteúdo</h1>

            <div class="bg-gray-800 p-6 rounded-lg shadow-lg mb-8">
                <h2 class="text-xl font-bold text-white mb-4">Relatórios e Ferramentas</h2>
                <div id="report-tabs" class="flex flex-wrap gap-3 border-b border-gray-700 pb-4 mb-4">
                    <button data-report-type="movies-no-links" class="report-btn bg-gray-700 hover:bg-gray-600 text-white font-semibold px-4 py-2 rounded-md transition text-sm">
                        Filmes Sem Links (<span id="count-movies-no-links">...</span>)
                    </button>
                     <button data-report-type="movies-with-links" class="report-btn bg-gray-700 hover:bg-gray-600 text-white font-semibold px-4 py-2 rounded-md transition text-sm">
                        Filmes Com Links (<span id="count-movies-with-links">...</span>)
                    </button>
                    <button data-report-type="series-with-links" class="report-btn bg-gray-700 hover:bg-gray-600 text-white font-semibold px-4 py-2 rounded-md transition text-sm">
                        Séries Com Links (<span id="count-series-with-links">...</span>)
                    </button>
                     <button data-report-type="episodes-with-links" class="report-btn bg-gray-700 hover:bg-gray-600 text-white font-semibold px-4 py-2 rounded-md transition text-sm">
                        Episódios Com Links (<span id="count-episodes-with-links">...</span>)
                    </button>
                </div>
                
                <div class="mt-4 flex flex-wrap gap-3">
                    <button id="download-movies-txt-btn" class="bg-emerald-600 hover:bg-emerald-700 text-white font-semibold px-4 py-2 rounded-md transition text-sm">
                        BAIXAR FILMES (.MP4) .TXT
                    </button>
                    <button id="download-series-txt-btn" class="bg-sky-600 hover:bg-sky-700 text-white font-semibold px-4 py-2 rounded-md transition text-sm">
                        BAIXAR TODAS AS SÉRIES .TXT
                    </button>
                </div>

                <div class="mt-4 border-t border-gray-700 pt-4">
                    <button id="force-firestore-all-movies-btn" class="bg-orange-600 hover:bg-orange-700 text-white font-semibold px-4 py-2 rounded-md transition text-sm">
                        Forçar Firestore para Filmes com Link .MP4
                    </button>
                </div>

                <div id="report-results-container" class="space-y-3 mt-4">
                    <p class="text-gray-400">Selecione um relatório para ver os resultados.</p>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                
                <div class="lg:col-span-1 flex flex-col gap-8">
                    <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                        <h2 class="text-xl font-bold text-white mb-4">Adicionar Rápido por ID</h2>
                        <div class="flex flex-col sm:flex-row gap-2">
                            <input id="quick-add-tmdb-id" type="text" placeholder="ID do TMDB (ex: 1053024)" class="flex-grow bg-gray-700 border border-gray-600 rounded-md p-2 text-white focus:outline-none focus:border-yellow-500">
                            <select id="quick-add-media-type" class="bg-gray-700 border border-gray-600 rounded-md p-2 text-white focus:outline-none focus:border-yellow-500">
                                <option value="movie">Filme</option>
                                <option value="tv">Série</option>
                            </select>
                            <button id="quick-add-btn" class="bg-teal-500 text-white font-bold px-4 py-2 rounded-md hover:bg-teal-600 transition">Carregar</button>
                        </div>
                    </div>
                    
                    <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                        <h2 class="text-xl font-bold text-white mb-4">Buscar no TMDB (Alternativo)</h2>
                        <div class="flex gap-2">
                            <input id="catalog-search-input" type="text" placeholder="Nome do filme ou série..." class="flex-grow bg-gray-700 border border-gray-600 rounded-md p-2 text-white focus:outline-none focus:border-yellow-500">
                            <button id="catalog-search-btn" class="bg-yellow-500 text-gray-900 font-bold px-4 py-2 rounded-md hover:bg-yellow-600 transition">Buscar</button>
                        </div>
                        <div id="catalog-list" class="mt-4 space-y-3 max-h-80 overflow-y-auto">
                        </div>
                    </div>
                </div>

                <div class="lg:col-span-1 bg-gray-800 p-6 rounded-lg shadow-lg">
                    <h2 class="text-xl font-bold text-white mb-4">Adicionar/Editar Links</h2>
                    <form id="media-form" class="space-y-4">
                        <input type="hidden" id="tmdb-id">
                        <input type="hidden" id="media-type">
                        
                        <div>
                            <div class="flex justify-between items-start">
                                <div>
                                    <label for="media-title-input" class="block text-sm font-medium text-gray-400">Título (Editável)</label>
                                    <input type="text" id="media-title-input" class="w-full bg-gray-700 border border-gray-600 rounded-md p-2 mt-1 text-white focus:outline-none focus:border-yellow-500" placeholder="Título do filme ou série">
                                    </div>
                                <div id="force-firestore-status" class="hidden text-xs font-bold p-2 rounded-md"></div>
                            </div>
                        </div>

                        <div id="movie-section" class="hidden space-y-3">
                            <h3 class="text-md font-semibold border-b border-gray-700 pb-2">Links do Filme</h3>
                            <div id="movie-urls-list" class="space-y-4">
                                </div>
                            <button type="button" id="add-movie-url-btn" class="text-sm bg-blue-600 hover:bg-blue-700 text-white font-semibold px-3 py-1 rounded-md transition">+ Adicionar Resolução</button>
                        </div>

                        <div id="series-section" class="hidden space-y-3">
                            <h3 class="text-md font-semibold border-b border-gray-700 pb-2">Episódios da Série</h3>
                            <div class="flex flex-wrap items-end gap-2">
                                <div class="flex-grow">
                                    <label for="season-selector" class="text-sm font-medium text-gray-400">Selecione a Temporada:</label>
                                    <select id="season-selector" class="w-full mt-1 bg-gray-700 border border-gray-600 p-2 rounded focus:outline-none focus:border-yellow-500"></select>
                                </div>
                                <button type="button" id="invert-order-btn" class="hidden bg-gray-500 hover:bg-gray-600 text-white font-semibold px-4 py-2 rounded-md transition self-end whitespace-nowrap">Inverter Ordem</button>
                                <button type="button" id="copy-all-links-form-btn" class="hidden bg-cyan-600 hover:bg-cyan-700 text-white font-semibold px-4 py-2 rounded-md transition self-end whitespace-nowrap">Copiar Todos os Links</button>
                                <button type="button" id="bulk-import-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold px-4 py-2 rounded-md transition self-end whitespace-nowrap">Importar em Massa</button>
                            </div>
                            <textarea id="bulk-import-textarea" class="hidden w-full bg-gray-700 border border-gray-600 p-2 rounded text-sm mt-2" rows="8" placeholder="Cole os links, um por linha.&#10;Formatos aceitos:&#10;1. Lista de links (serão atribuídos em ordem)&#10;https://link1.com&#10;https://link2.com&#10;2. Formato com EP&#10;EP01: https://link1.com&#10;EP02: https://link2.com&#10;3. Com Temporadas&#10;Temporada 1&#10;EP01: https://link1.com"></textarea>
                            <div id="episodes-list" class="space-y-4 max-h-96 overflow-y-auto p-2 bg-gray-900 rounded-md">
                                </div>
                        </div>
                        
                        <div class="flex justify-end gap-4 pt-4">
                            <button type="button" id="cancel-edit-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold px-6 py-2 rounded-md transition">Cancelar</button>
                            <button type="submit" id="save-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold px-6 py-2 rounded-md transition flex items-center justify-center" disabled>
                                <span class="btn-text">Salvar</span>
                                <div class="loader hidden ml-2"></div>
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </main>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, onAuthStateChanged, signOut, GoogleAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, getDocs, updateDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCNEGDpDLuWYrxTkoONy4oQujnatx6KIS8",
            authDomain: "cineveok.firebaseapp.com",
            projectId: "cineveok",
            storageBucket: "cineveok.appspot.com",
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const firestore = getFirestore(app);
        const googleProvider = new GoogleAuthProvider();

        const ADMIN_UIDS = ['7ZNDEaW95BMCm4zk1GIP9t6WwHn2', 'YHBxowyZv0hzld7hypnEWHvx5K82', 'QkqhyXbcURYt2zPhblWQLnJEY023', 'tMdWtke7PYBk4l4UNKnbrLQ4i32'];
        const TMDB_API_KEY = '678cf2db5c3ab4a315d8ec632c493c7d';

        let bulkImportData = {};
        let allMediaCache = [];
        let allEpisodesWithLinksCache = [];

        const ui = {
            loginScreen: document.getElementById('login-screen'),
            adminPanel: document.getElementById('admin-panel'),
            loginForm: document.getElementById('login-form'),
            emailInput: document.getElementById('email'),
            passwordInput: document.getElementById('password'),
            googleLoginBtn: document.getElementById('google-login-btn'),
            userEmailSpan: document.getElementById('user-email'),
            catalogSearchInput: document.getElementById('catalog-search-input'),
            catalogSearchBtn: document.getElementById('catalog-search-btn'),
            catalogList: document.getElementById('catalog-list'),
            mediaForm: document.getElementById('media-form'),
            tmdbIdInput: document.getElementById('tmdb-id'),
            mediaTypeInput: document.getElementById('media-type'),
            mediaTitleInput: document.getElementById('media-title-input'),
            forceFirestoreStatus: document.getElementById('force-firestore-status'),
            movieSection: document.getElementById('movie-section'),
            seriesSection: document.getElementById('series-section'),
            seasonSelector: document.getElementById('season-selector'),
            episodesList: document.getElementById('episodes-list'),
            movieUrlsList: document.getElementById('movie-urls-list'),
            saveBtn: document.getElementById('save-btn'),
            cancelEditBtn: document.getElementById('cancel-edit-btn'),
            bulkImportBtn: document.getElementById('bulk-import-btn'),
            bulkImportTextarea: document.getElementById('bulk-import-textarea'),
            invertOrderBtn: document.getElementById('invert-order-btn'),
            quickAddTmdbId: document.getElementById('quick-add-tmdb-id'),
            quickAddMediaType: document.getElementById('quick-add-media-type'),
            quickAddBtn: document.getElementById('quick-add-btn'),
            reportTabs: document.getElementById('report-tabs'),
            reportResultsContainer: document.getElementById('report-results-container'),
            logoutButton: document.getElementById('logout-button'),
            addMovieUrlBtn: document.getElementById('add-movie-url-btn'),
            copyAllLinksFormBtn: document.getElementById('copy-all-links-form-btn'),
            forceFirestoreAllMoviesBtn: document.getElementById('force-firestore-all-movies-btn'),
            downloadMoviesBtn: document.getElementById('download-movies-txt-btn'),
            downloadSeriesBtn: document.getElementById('download-series-txt-btn'),
        };

        const showPanel = async (user) => {
            ui.userEmailSpan.textContent = user.email;
            ui.loginScreen.classList.add('hidden');
            ui.adminPanel.classList.remove('hidden');
            await loadAndProcessAllMedia(); 
        };

        const showLogin = () => {
            ui.loginScreen.classList.remove('hidden');
            ui.adminPanel.classList.add('hidden');
        };
        
        const performSearch = async () => {
            const query = ui.catalogSearchInput.value.trim();
            if (!query) return;
            ui.catalogList.innerHTML = '<div class="loader mx-auto"></div>';
            try {
                const response = await fetch(`https://api.themoviedb.org/3/search/multi?api_key=${TMDB_API_KEY}&language=pt-BR&query=${encodeURIComponent(query)}`);
                const data = await response.json();
                displaySearchResults(data.results);
            } catch (error) {
                ui.catalogList.innerHTML = '<p class="text-red-400">Erro ao buscar.</p>';
            }
        };

        const createMediaListItemHTML = (item) => {
            const title = item.title || item.name;
            const year = (item.release_date || item.first_air_date || '').substring(0, 4);
            const typeLabel = item.type === 'series' || item.media_type === 'tv' ? 'Série' : 'Filme';
            const tmdbType = item.media_type || (item.type === 'series' ? 'tv' : 'movie');
            const isForced = item.forceFirestore === true;

            const copyButtonHTML = tmdbType === 'tv' 
                ? `<button class="copy-all-links-btn bg-cyan-600 text-white text-xs font-bold px-3 py-1 rounded hover:bg-cyan-700" data-tmdb-id="${item.id}">Copiar Links</button>` 
                : '';

            return `
                <div class="bg-gray-700 p-3 rounded-md">
                    <div>
                        <p class="font-semibold text-white">${title} ${year ? `(${year})` : ''}</p>
                        <p class="text-xs text-gray-400">${typeLabel} - ID: ${item.id}</p>
                    </div>
                    <div class="mt-3 flex items-center justify-end gap-2">
                        ${copyButtonHTML} 
                        <button class="force-firestore-btn text-xs font-bold px-3 py-1 rounded transition ${isForced ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-gray-600 hover:bg-gray-500 text-gray-300'}" data-tmdb-id="${item.id}" data-tmdb-type="${tmdbType}">
                            ${isForced ? 'Forçando Firestore' : 'Padrão API'}
                        </button>
                        <button class="manage-btn bg-yellow-600 text-white text-xs font-bold px-3 py-1 rounded hover:bg-yellow-700" data-tmdb-id="${item.id}" data-tmdb-type="${tmdbType}">
                            Gerenciar
                        </button>
                    </div>
                </div>
            `;
        }
        
        const createEpisodeListItemHTML = (episode) => {
            return `
                <div class="bg-gray-700 p-3 rounded-md">
                    <div>
                        <p class="font-semibold text-white">${episode.seriesTitle}</p>
                        <p class="text-xs text-gray-400">Temporada ${episode.seasonNumber}, Episódio ${episode.episodeNumber}</p>
                    </div>
                    <div class="mt-3 flex items-center justify-end gap-2">
                        <button class="manage-btn bg-yellow-600 text-white text-xs font-bold px-3 py-1 rounded hover:bg-yellow-700" data-tmdb-id="${episode.seriesId}" data-tmdb-type="tv">
                            Gerenciar Série
                        </button>
                    </div>
                </div>
            `;
        };
        
        const displaySearchResults = (results) => {
            ui.catalogList.innerHTML = '';
            results
                .filter(r => r.media_type === 'movie' || r.media_type === 'tv')
                .forEach(item => {
                    const cached = allMediaCache.find(c => c.id == item.id) || {};
                    ui.catalogList.innerHTML += createMediaListItemHTML({...item, ...cached});
                });
        };
        
        const prepareFormForEditing = async (id, type) => {
            resetForm();
            ui.mediaTitleInput.value = "Carregando...";
            ui.tmdbIdInput.value = id;
            ui.mediaTypeInput.value = type;
            ui.saveBtn.disabled = false;

            try {
                const tmdbResponse = await fetch(`https://api.themoviedb.org/3/${type}/${id}?api_key=${TMDB_API_KEY}&language=pt-BR`);
                if (!tmdbResponse.ok) throw new Error('Conteúdo não encontrado no TMDB.');
                const tmdbData = await tmdbResponse.json();
                
                const firestoreDocRef = doc(firestore, "media", id.toString());
                const docSnap = await getDoc(firestoreDocRef);
                const firestoreData = docSnap.exists() ? docSnap.data() : {};
                
                ui.mediaTitleInput.value = firestoreData.title || tmdbData.title || tmdbData.name;
                
                if (firestoreData.forceFirestore) {
                    ui.forceFirestoreStatus.textContent = 'Usando Apenas Firestore';
                    ui.forceFirestoreStatus.className = 'text-xs font-bold p-2 rounded-md bg-green-500 text-white';
                    ui.forceFirestoreStatus.classList.remove('hidden');
                } else {
                     ui.forceFirestoreStatus.classList.add('hidden');
                }

                if (type === 'movie') {
                    ui.movieSection.classList.remove('hidden');
                    if (firestoreData.urls && firestoreData.urls.length > 0) {
                        firestoreData.urls.forEach(urlData => addMovieResolutionUI(urlData.url, urlData.quality, urlData.thumbnailUrl));
                    } else {
                        addMovieResolutionUI();
                    }
                } else if (type === 'tv') {
                    ui.seriesSection.classList.remove('hidden');
                    ui.copyAllLinksFormBtn.classList.remove('hidden');
                    ui.seasonSelector.innerHTML = tmdbData.seasons
                        .filter(s => s.season_number > 0)
                        .map(s => `<option value="${s.season_number}">${s.name}</option>`).join('');
                    
                    await loadEpisodesForSeason(id, ui.seasonSelector.value, firestoreData);
                }

            } catch (error) {
                console.error(error);
                alert(error.message || 'Erro ao carregar detalhes do item.');
                resetForm();
            }
        };

        const loadEpisodesForSeason = async (seriesId, seasonNumber, firestoreData) => {
            ui.episodesList.innerHTML = '<div class="loader mx-auto"></div>';
            try {
                const response = await fetch(`https://api.themoviedb.org/3/tv/${seriesId}/season/${seasonNumber}?api_key=${TMDB_API_KEY}&language=pt-BR`);
                const seasonData = await response.json();
                ui.episodesList.innerHTML = '';

                seasonData.episodes.forEach(ep => {
                    const existingEpisode = firestoreData.seasons?.[seasonNumber]?.episodes?.find(e => e.episode_number == ep.episode_number);
                    const existingUrl = existingEpisode?.urls?.[0]?.url || '';
                    const existingQuality = existingEpisode?.urls?.[0]?.quality || 'HD';
                    const existingThumbnailUrl = existingEpisode?.urls?.[0]?.thumbnailUrl || '';

                    const div = document.createElement('div');
                    div.className = 'p-3 bg-gray-800 rounded-md';
                    div.innerHTML = `
                        <div class="flex items-center gap-2">
                            <span class="font-bold text-sm w-8 text-center">${ep.episode_number}</span>
                            <span class="flex-grow text-sm text-gray-300 truncate" title="${ep.name}">${ep.name}</span>
                            <button type="button" class="remove-episode-btn text-red-500 hover:text-red-400 font-bold px-2" title="Limpar link do episódio">X</button>
                        </div>
                        <div class="mt-2 space-y-2">
                            <div class="flex items-center gap-2">
                                <input type="text" value="${existingQuality}" class="episode-quality bg-gray-700 border border-gray-600 p-1 rounded text-xs w-20" placeholder="HD">
                                <input type="text" data-episode-number="${ep.episode_number}" value="${existingUrl}" class="episode-url flex-grow bg-gray-700 border border-gray-600 p-1 rounded text-xs" placeholder="URL do Embed">
                            </div>
                             <input type="text" value="${existingThumbnailUrl}" class="episode-thumbnail-url w-full bg-gray-700 border border-gray-600 p-1 rounded text-xs" placeholder="URL Miniaturas (.mp4)">
                        </div>
                    `;
                    ui.episodesList.appendChild(div);
                });
                
                populateFromBulkData(seasonNumber);

            } catch (error) {
                ui.episodesList.innerHTML = '<p class="text-red-400">Erro ao carregar episódios.</p>';
            }
        };
        
        const resetForm = () => {
            ui.mediaForm.reset();
            ui.mediaTitleInput.value = '';
            ui.tmdbIdInput.value = '';
            ui.mediaTypeInput.value = '';
            ui.movieSection.classList.add('hidden');
            ui.seriesSection.classList.add('hidden');
            ui.movieUrlsList.innerHTML = '';
            ui.episodesList.innerHTML = '';
            ui.seasonSelector.innerHTML = '';
            ui.saveBtn.disabled = true;
            ui.bulkImportTextarea.classList.add('hidden');
            ui.invertOrderBtn.classList.add('hidden');
            ui.copyAllLinksFormBtn.classList.add('hidden'); 
            ui.bulkImportTextarea.value = '';
            ui.bulkImportBtn.textContent = 'Importar em Massa';
            ui.forceFirestoreStatus.classList.add('hidden');
            bulkImportData = {};
        };
        
        const addMovieResolutionUI = (url = '', quality = 'HD', thumbnailUrl = '') => {
            const div = document.createElement('div');
            div.className = 'p-3 bg-gray-700/50 rounded-md space-y-2 relative';
            div.innerHTML = `
                <button type="button" class="remove-btn absolute top-2 right-2 text-red-500 hover:text-red-400 font-bold">X</button>
                <div class="flex items-center gap-2">
                    <input type="text" value="${quality}" class="movie-quality bg-gray-700 border border-gray-600 p-2 rounded w-24" placeholder="Qualidade">
                    <input type="text" value="${url}" class="movie-url flex-grow bg-gray-700 border border-gray-600 p-2 rounded" placeholder="URL do Embed">
                </div>
                <input type="text" value="${thumbnailUrl}" class="movie-thumbnail-url w-full bg-gray-700 border border-gray-600 p-2 rounded" placeholder="URL Miniaturas (.mp4)">
            `;
            ui.movieUrlsList.appendChild(div);
        };
        
        const handleMediaFormSubmit = async (e) => {
            e.preventDefault();
            const id = ui.tmdbIdInput.value;
            const type = ui.mediaTypeInput.value;
            const title = ui.mediaTitleInput.value.trim();

            if (!id || !type) return alert('Nenhum item selecionado.');
            if (!title) return alert('O campo de título não pode estar vazio.');

            ui.saveBtn.querySelector('.btn-text').textContent = 'Salvando...';
            ui.saveBtn.querySelector('.loader').classList.remove('hidden');
            ui.saveBtn.disabled = true;

            const docRef = doc(firestore, "media", id);

            try {
                const docSnap = await getDoc(docRef);
                const existingData = docSnap.exists() ? docSnap.data() : {};
                
                const mediaData = { 
                    ...existingData, 
                    type: type === 'tv' ? 'series' : 'movie',
                    title: title
                };

                if (type === 'movie') {
                    const urls = [];
                    document.querySelectorAll('#movie-urls-list > div').forEach(div => {
                        const url = div.querySelector('.movie-url').value.trim();
                        const quality = div.querySelector('.movie-quality').value.trim() || 'HD';
                        const thumbnailUrl = div.querySelector('.movie-thumbnail-url').value.trim();
                        if (url) urls.push({ quality, url, thumbnailUrl });
                    });
                    mediaData.urls = urls;
                } else if (type === 'tv') {
                    const seasonsToSave = existingData.seasons || {};

                    const currentSeasonNumber = ui.seasonSelector.value;
                    const currentSeasonEpisodesFromForm = [];
                    document.querySelectorAll('#episodes-list > div').forEach(row => {
                        const urlInput = row.querySelector('.episode-url');
                        const qualityInput = row.querySelector('.episode-quality');
                        const thumbnailInput = row.querySelector('.episode-thumbnail-url');
                        
                        const url = urlInput.value.trim();
                        if (url) {
                            currentSeasonEpisodesFromForm.push({
                                episode_number: parseInt(urlInput.dataset.episodeNumber),
                                urls: [{ 
                                    quality: qualityInput.value.trim() || 'HD', 
                                    url: url,
                                    thumbnailUrl: thumbnailInput.value.trim()
                                }]
                            });
                        }
                    });

                    if (!seasonsToSave[currentSeasonNumber]) {
                        seasonsToSave[currentSeasonNumber] = {};
                    }
                    seasonsToSave[currentSeasonNumber].episodes = currentSeasonEpisodesFromForm;
                    seasonsToSave[currentSeasonNumber].name = ui.seasonSelector.options[ui.seasonSelector.selectedIndex].text;
                    
                    // Salvar também dados de importação em massa (se houver)
                     for (const [seasonNumber, episodes] of Object.entries(bulkImportData)) {
                        if (!seasonsToSave[seasonNumber]) seasonsToSave[seasonNumber] = { episodes: [] };
                        for (const [epNumber, url] of Object.entries(episodes)) {
                            const existingEpIndex = seasonsToSave[seasonNumber].episodes.findIndex(e => e.episode_number == epNumber);
                            if (existingEpIndex !== -1) {
                                seasonsToSave[seasonNumber].episodes[existingEpIndex].urls[0].url = url;
                            } else if (url) {
                                seasonsToSave[seasonNumber].episodes.push({
                                    episode_number: parseInt(epNumber),
                                    urls: [{ quality: 'HD', url, thumbnailUrl: '' }]
                                });
                            }
                        }
                    }

                    mediaData.seasons = seasonsToSave;
                }
                
                await setDoc(docRef, mediaData, { merge: true });
                
                updateCacheAndUI(id, mediaData);
                
                alert('Dados salvos com sucesso!');
                resetForm();

            } catch (error) {
                alert('Erro ao salvar os dados.');
                console.error("Erro: ", error);
            } finally {
                ui.saveBtn.querySelector('.btn-text').textContent = 'Salvar';
                ui.saveBtn.querySelector('.loader').classList.add('hidden');
                ui.saveBtn.disabled = false;
            }
        };

        const handleBulkImport = () => {
            const text = ui.bulkImportTextarea.value.trim();
            if (!text) { alert('A área de texto está vazia.'); return; }

            bulkImportData = {};
            let currentSeason = ui.seasonSelector.value;
            let simpleLinkCounter = 1;
            const lines = text.split('\n').filter(line => line.trim() !== '');

            lines.forEach(line => {
                const seasonMatch = line.match(/Temporada\s+(\d+)/i);
                if (seasonMatch) {
                    currentSeason = parseInt(seasonMatch[1], 10).toString();
                    if (!bulkImportData[currentSeason]) bulkImportData[currentSeason] = {};
                    simpleLinkCounter = 1; 
                    return; 
                }

                const episodeMatch = line.match(/EP(\d+):\s*(https?:\/\/\S+)/i);
                if (episodeMatch) {
                    const episodeNumber = parseInt(episodeMatch[1], 10);
                    const url = episodeMatch[2].trim();
                    if (!bulkImportData[currentSeason]) bulkImportData[currentSeason] = {};
                    bulkImportData[currentSeason][episodeNumber] = url;
                    return;
                }

                if (line.startsWith('http')) {
                    if (!bulkImportData[currentSeason]) bulkImportData[currentSeason] = {};
                    bulkImportData[currentSeason][simpleLinkCounter] = line.trim();
                    simpleLinkCounter++;
                }
            });

            populateFromBulkData(ui.seasonSelector.value);
            alert('Links processados. Verifique os campos e salve.');
        };

        const populateFromBulkData = (seasonNumber) => {
            const seasonData = bulkImportData[seasonNumber];
            if (seasonData) {
                for (const [epNumber, url] of Object.entries(seasonData)) {
                    const episodeInput = document.querySelector(`.episode-url[data-episode-number="${epNumber}"]`);
                    if (episodeInput) episodeInput.value = url;
                }
            }
        };
        
        const handleInvertOrder = () => {
            const lines = ui.bulkImportTextarea.value.split('\n');
            ui.bulkImportTextarea.value = lines.reverse().join('\n');
        };

        const loadAndProcessAllMedia = async () => {
            const mediaCollection = collection(firestore, 'media');
            try {
                const querySnapshot = await getDocs(mediaCollection);
                allMediaCache = [];
                allEpisodesWithLinksCache = [];

                querySnapshot.forEach(doc => {
                    const data = doc.data();
                    const cacheItem = {
                        id: doc.id,
                        type: data.type,
                        title: data.title,
                        forceFirestore: data.forceFirestore || false,
                        hasLinks: false, 
                        meetsMp4Criteria: false,
                        episodesWithLinksCount: 0
                    };

                    if (data.type === 'movie' && Array.isArray(data.urls) && data.urls.length > 0) {
                        let hasAnyLink = false;
                        let hasMp4Link = false;
                        let hasForbiddenLink = false;

                        for (const urlData of data.urls) {
                            if (urlData && urlData.url) {
                                hasAnyLink = true;
                                const url = urlData.url.toLowerCase();
                                if (url.endsWith('.mp4')) {
                                    hasMp4Link = true;
                                }
                                if (url.includes('abyss') || url.includes('short.icu') || url.includes('superflix')) {
                                    hasForbiddenLink = true;
                                }
                            }
                        }
                        
                        cacheItem.hasLinks = hasAnyLink;
                        if (hasMp4Link && !hasForbiddenLink) {
                            cacheItem.meetsMp4Criteria = true;
                        }
                    }

                    if (data.type === 'series' && data.seasons) {
                        let count = 0;
                        Object.keys(data.seasons).forEach(seasonNumber => {
                            const season = data.seasons[seasonNumber];
                            if (season && Array.isArray(season.episodes)) {
                                season.episodes.forEach(ep => {
                                    if (ep && Array.isArray(ep.urls) && ep.urls.some(u => u && u.url)) {
                                        count++;
                                        allEpisodesWithLinksCache.push({
                                            seriesId: doc.id,
                                            seriesTitle: data.title,
                                            seasonNumber: seasonNumber,
                                            episodeNumber: ep.episode_number
                                        });
                                    }
                                });
                            }
                        });
                        cacheItem.episodesWithLinksCount = count;
                    }
                    allMediaCache.push(cacheItem);
                });
                updateReportCounts();
            } catch (error) {
                console.error("Erro ao carregar mídia para relatórios:", error);
                alert("Não foi possível carregar os dados para os relatórios.");
            }
        };

        const updateReportCounts = () => {
            const moviesNoLinks = allMediaCache.filter(m => m.type === 'movie' && !m.hasLinks).length;
            const moviesWithLinks = allMediaCache.filter(m => m.type === 'movie' && m.hasLinks).length;
            const seriesWithLinks = allMediaCache.filter(m => m.type === 'series' && m.episodesWithLinksCount > 0).length;
            const episodesWithLinks = allEpisodesWithLinksCache.length;

            document.getElementById('count-movies-no-links').textContent = moviesNoLinks;
            document.getElementById('count-movies-with-links').textContent = moviesWithLinks;
            document.getElementById('count-series-with-links').textContent = seriesWithLinks;
            document.getElementById('count-episodes-with-links').textContent = episodesWithLinks;
        };
        
        const updateCacheAndUI = (id, mediaData) => {
            let itemInCache = allMediaCache.find(item => item.id === id);

            if (!itemInCache) {
                itemInCache = { id, type: mediaData.type };
                allMediaCache.push(itemInCache);
            }

            itemInCache.title = mediaData.title;
            itemInCache.forceFirestore = mediaData.forceFirestore || false;

            if (mediaData.type === 'movie') {
                let hasAnyLink = false;
                let hasMp4Link = false;
                let hasForbiddenLink = false;

                if (Array.isArray(mediaData.urls) && mediaData.urls.length > 0) {
                     for (const urlData of mediaData.urls) {
                        if (urlData && urlData.url) {
                            hasAnyLink = true;
                            const url = urlData.url.toLowerCase();
                            if (url.endsWith('.mp4')) hasMp4Link = true;
                            if (url.includes('abyss') || url.includes('short.icu') || url.includes('superflix')) hasForbiddenLink = true;
                        }
                    }
                }
                itemInCache.hasLinks = hasAnyLink;
                itemInCache.meetsMp4Criteria = hasMp4Link && !hasForbiddenLink;
            } else if (mediaData.type === 'series') {
                allEpisodesWithLinksCache = allEpisodesWithLinksCache.filter(ep => ep.seriesId !== id);
                
                let count = 0;
                if (mediaData.seasons) {
                    Object.keys(mediaData.seasons).forEach(seasonNumber => {
                        const season = mediaData.seasons[seasonNumber];
                        if (season && Array.isArray(season.episodes)) {
                             season.episodes.forEach(ep => {
                                if (ep && Array.isArray(ep.urls) && ep.urls.some(u => u && u.url)) {
                                    count++;
                                    allEpisodesWithLinksCache.push({
                                        seriesId: id,
                                        seriesTitle: mediaData.title,
                                        seasonNumber: seasonNumber,
                                        episodeNumber: ep.episode_number
                                    });
                                }
                            });
                        }
                    });
                }
                itemInCache.episodesWithLinksCount = count;
            }

            updateReportCounts();
        };

        const displayReportResults = (reportType) => {
            let filteredMedia = [];
            let reportTitle = "";
            let useEpisodeRenderer = false;

            if (reportType === 'movies-no-links') {
                filteredMedia = allMediaCache.filter(m => m.type === 'movie' && !m.hasLinks);
                reportTitle = "Filmes Sem Links";
            } else if (reportType === 'movies-with-links') {
                filteredMedia = allMediaCache.filter(m => m.type === 'movie' && m.hasLinks);
                reportTitle = "Filmes Com Links";
            } else if (reportType === 'series-with-links') {
                filteredMedia = allMediaCache.filter(m => m.type === 'series' && m.episodesWithLinksCount > 0);
                reportTitle = "Séries Com Links";
            } else if (reportType === 'episodes-with-links') {
                filteredMedia = allEpisodesWithLinksCache;
                reportTitle = "Episódios Com Links";
                useEpisodeRenderer = true;
            }

            if (filteredMedia.length === 0) {
                ui.reportResultsContainer.innerHTML = `<p class="text-gray-400">Nenhum item encontrado para "${reportTitle}".</p>`;
                return;
            }
            
            let listHtml = `<div id="report-results-list" class="space-y-2 max-h-96 overflow-y-auto pr-2">`;
            filteredMedia.forEach(item => {
                listHtml += useEpisodeRenderer ? createEpisodeListItemHTML(item) : createMediaListItemHTML(item);
            });
            listHtml += `</div>`;
            ui.reportResultsContainer.innerHTML = listHtml;
        };
        
        const toggleForceFirestore = async (button) => {
            const id = button.dataset.tmdbId;
            if (!id) return;

            button.disabled = true;
            button.textContent = '...';
            const docRef = doc(firestore, "media", id);

            try {
                const docSnap = await getDoc(docRef);
                const currentStatus = docSnap.exists() ? docSnap.data().forceFirestore === true : false;
                const newStatus = !currentStatus;

                await setDoc(docRef, { forceFirestore: newStatus }, { merge: true });
                
                const cachedItem = allMediaCache.find(item => item.id == id);
                if (cachedItem) {
                    cachedItem.forceFirestore = newStatus;
                }

                button.textContent = newStatus ? 'Forçando Firestore' : 'Padrão API';
                button.classList.toggle('bg-green-600', newStatus);
                button.classList.toggle('hover:bg-green-700', newStatus);
                button.classList.toggle('text-white', newStatus);
                button.classList.toggle('bg-gray-600', !newStatus);
                button.classList.toggle('hover:bg-gray-500', !newStatus);
                button.classList.toggle('text-gray-300', !newStatus);

            } catch (error) {
                console.error("Erro ao alternar 'forceFirestore':", error);
                alert("Falha ao atualizar o status.");
                const cachedItem = allMediaCache.find(item => item.id == id);
                const isForced = cachedItem ? cachedItem.forceFirestore : false;
                button.textContent = isForced ? 'Forçando Firestore' : 'Padrão API';
            } finally {
                button.disabled = false;
            }
        };

        const forceFirestoreForAllLinkedMovies = async () => {
            const confirmation = confirm("Você tem certeza que deseja ativar 'Forçar Firestore' para TODOS os filmes que possuem link .mp4 e que não sejam de domínios como abyss, short.icu ou superflix?");
            if (!confirmation) {
                return;
            }

            const moviesToUpdate = allMediaCache.filter(item => item.type === 'movie' && item.meetsMp4Criteria && !item.forceFirestore);

            if (moviesToUpdate.length === 0) {
                alert("Nenhum filme que atenda aos critérios (.mp4, sem domínios proibidos) precisava ser atualizado.");
                return;
            }

            const button = ui.forceFirestoreAllMoviesBtn;
            const originalText = button.textContent;
            button.disabled = true;
            
            try {
                for (let i = 0; i < moviesToUpdate.length; i++) {
                    const movie = moviesToUpdate[i];
                    button.textContent = `Atualizando... (${i + 1}/${moviesToUpdate.length})`;
                    const docRef = doc(firestore, "media", movie.id);
                    await setDoc(docRef, { forceFirestore: true }, { merge: true });
                }

                alert(`${moviesToUpdate.length} filmes concluídos.`);
                
                await loadAndProcessAllMedia();
                document.querySelectorAll('.report-btn').forEach(btn => btn.classList.remove('active'));
                ui.reportResultsContainer.innerHTML = `<p class="text-gray-400">Selecione um relatório para ver os resultados.</p>`;

            } catch (error) {
                console.error("Erro ao forçar Firestore em massa:", error);
                alert("Ocorreu um erro durante a atualização em massa. Verifique o console para mais detalhes.");
            } finally {
                button.disabled = false;
                button.textContent = originalText;
            }
        };

        const copyAllSeriesLinksToClipboard = async (seriesId) => {
            if (!seriesId) return;

            try {
                const docRef = doc(firestore, "media", seriesId.toString());
                const docSnap = await getDoc(docRef);

                if (!docSnap.exists() || !docSnap.data().seasons) {
                    alert('Nenhum link encontrado para esta série no banco de dados.');
                    return;
                }

                const firestoreData = docSnap.data();
                let outputText = '';

                const sortedSeasonNumbers = Object.keys(firestoreData.seasons).sort((a, b) => parseInt(a) - parseInt(b));

                for (const seasonNumber of sortedSeasonNumbers) {
                    const season = firestoreData.seasons[seasonNumber];
                    if (season && season.episodes && season.episodes.length > 0) {
                        outputText += `Temporada ${seasonNumber}\n`;
                        
                        const sortedEpisodes = season.episodes.sort((a, b) => a.episode_number - b.episode_number);

                        sortedEpisodes.forEach(ep => {
                            if (ep.urls && ep.urls.length > 0 && ep.urls[0].url) {
                                const epNumberFormatted = String(ep.episode_number).padStart(2, '0');
                                outputText += `EP${epNumberFormatted}: ${ep.urls[0].url}\n`;
                            }
                        });
                        outputText += `\n`; 
                    }
                }

                if (outputText.trim() === '') {
                    alert('A série possui temporadas, mas nenhum link de episódio foi encontrado.');
                    return;
                }

                await navigator.clipboard.writeText(outputText.trim());
                alert('Todos os links da série foram copiados com sucesso!');

            } catch (error) {
                console.error("Erro ao copiar links da série:", error);
                alert("Ocorreu um erro ao tentar copiar os links.");
            }
        };

        const downloadFile = (filename, text) => {
            const element = document.createElement('a');
            const file = new Blob([text], {type: 'text/plain;charset=utf-8'});
            element.href = URL.createObjectURL(file);
            element.download = filename;
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
        }

        const downloadAllMoviesAsTxt = async () => {
            const button = ui.downloadMoviesBtn;
            const originalText = button.textContent;
            button.disabled = true;
            button.textContent = 'Gerando...';

            try {
                const moviesToProcess = allMediaCache.filter(m => m.type === 'movie' && m.hasLinks && /^\d+$/.test(m.id));
                if (moviesToProcess.length === 0) { alert('Nenhum filme com ID válido e links foi encontrado.'); return; }

                let txtContent = '';
                for (let i = 0; i < moviesToProcess.length; i++) {
                    const movie = moviesToProcess[i];
                    button.textContent = `Gerando... (${i + 1}/${moviesToProcess.length})`;
                    
                    const docRef = doc(firestore, "media", movie.id);
                    const docSnap = await getDoc(docRef);

                    if (docSnap.exists() && docSnap.data().urls) {
                        const firestoreData = docSnap.data();
                        const validUrls = firestoreData.urls.map(urlData => urlData.url).filter(url => {
                            if (!url) return false;
                            const lowerUrl = url.toLowerCase();
                            return lowerUrl.endsWith('.mp4') && !lowerUrl.includes('superflix') && !lowerUrl.includes('sinalprivado');
                        });

                        if (validUrls.length === 0) continue;

                        const tmdbResponse = await fetch(`https://api.themoviedb.org/3/movie/${movie.id}?api_key=${TMDB_API_KEY}&language=pt-BR`);
                        const tmdbData = await tmdbResponse.json();
                        const year = (tmdbData.release_date || '').substring(0, 4);
                        const title = firestoreData.title || tmdbData.title;
                        
                        txtContent += `${title} ${year ? `(${year})` : ''} - ${movie.id} << TMDB\n`;
                        validUrls.forEach(url => { txtContent += `${url}\n`; });
                        txtContent += '\n'; 
                    }
                }

                if (txtContent.trim() === '') {
                    alert('Nenhum filme atendeu aos critérios de filtro (ID válido, .mp4, sem domínios bloqueados).');
                } else {
                    downloadFile('filmes.txt', txtContent.trim());
                }
            } catch (error) {
                console.error("Erro ao gerar arquivo de filmes:", error);
                alert("Ocorreu um erro ao gerar o arquivo de filmes. Verifique o console.");
            } finally {
                button.disabled = false;
                button.textContent = originalText;
            }
        };

        const downloadAllSeriesAsTxt = async () => {
            const button = ui.downloadSeriesBtn;
            const originalText = button.textContent;
            button.disabled = true;
            button.textContent = 'Gerando...';
            
            try {
                const seriesToProcess = allMediaCache.filter(m => m.type === 'series' && m.episodesWithLinksCount > 0 && /^\d+$/.test(m.id));
                if (seriesToProcess.length === 0) { alert('Nenhuma série com ID válido e links foi encontrada.'); return; }

                let txtContent = '';
                 for (let i = 0; i < seriesToProcess.length; i++) {
                    const series = seriesToProcess[i];
                    button.textContent = `Gerando... (${i + 1}/${seriesToProcess.length})`;
                    
                    const docRef = doc(firestore, "media", series.id);
                    const docSnap = await getDoc(docRef);

                    if (docSnap.exists() && docSnap.data().seasons) {
                        const firestoreData = docSnap.data();
                        let seriesBlockContent = '';

                        const sortedSeasonNumbers = Object.keys(firestoreData.seasons).sort((a, b) => parseInt(a) - parseInt(b));

                        for (const seasonNumber of sortedSeasonNumbers) {
                            const season = firestoreData.seasons[seasonNumber];
                            let seasonHasValidLinks = false;
                            let seasonContent = '';

                            if (season && Array.isArray(season.episodes)) {
                                const sortedEpisodes = season.episodes.sort((a, b) => a.episode_number - b.episode_number);
                                
                                sortedEpisodes.forEach(ep => {
                                    if (ep.urls && ep.urls.length > 0 && ep.urls[0].url) {
                                        const url = ep.urls[0].url;
                                        const lowerUrl = url.toLowerCase();
                                        if (!lowerUrl.includes('superflix') && !lowerUrl.includes('sinalprivado')) {
                                            const epNumberFormatted = String(ep.episode_number).padStart(2, '0');
                                            seasonContent += `EP${epNumberFormatted}: ${url}\n`;
                                            seasonHasValidLinks = true;
                                        }
                                    }
                                });
                            }
                            if (seasonHasValidLinks) {
                                seriesBlockContent += `Temporada ${seasonNumber}\n${seasonContent}`;
                            }
                        }

                        if (seriesBlockContent) {
                            const tmdbResponse = await fetch(`https://api.themoviedb.org/3/tv/${series.id}?api_key=${TMDB_API_KEY}&language=pt-BR`);
                            const tmdbData = await tmdbResponse.json();
                            const year = (tmdbData.first_air_date || '').substring(0, 4);
                            const title = firestoreData.title || tmdbData.name;
                            
                            txtContent += `${title} ${year ? `(${year})` : ''} - ${series.id} << TMDB\n`;
                            txtContent += seriesBlockContent + '\n';
                        }
                    }
                }
                
                 if (txtContent.trim() === '') {
                    alert('Nenhuma série atendeu aos critérios de filtro (ID válido, sem domínios bloqueados).');
                } else {
                    downloadFile('series.txt', txtContent.trim());
                }
            } catch (error) {
                console.error("Erro ao gerar arquivo de séries:", error);
                alert("Ocorreu um erro ao gerar o arquivo de séries. Verifique o console.");
            } finally {
                button.disabled = false;
                button.textContent = originalText;
            }
        };

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            onAuthStateChanged(auth, (user) => {
                if (user && ADMIN_UIDS.includes(user.uid)) {
                    showPanel(user);
                } else {
                    if (user) { signOut(auth); }
                    showLogin();
                }
            });

            ui.loginForm.addEventListener('submit', (e) => { e.preventDefault(); signInWithEmailAndPassword(auth, ui.emailInput.value, ui.passwordInput.value).catch(() => alert('Credenciais inválidas.')); });
            
            ui.googleLoginBtn.addEventListener('click', () => {
                signInWithPopup(auth, googleProvider).catch((error) => {
                    console.error("Erro no login com Google:", error);
                    alert(`Erro ao tentar fazer login com o Google: ${error.message}`);
                });
            });

            ui.logoutButton.addEventListener('click', () => signOut(auth));
            ui.catalogSearchBtn.addEventListener('click', performSearch);
            ui.catalogSearchInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') performSearch(); });
            
            const universalClickListener = (e) => {
                const manageButton = e.target.closest('.manage-btn');
                if (manageButton) { prepareFormForEditing(manageButton.dataset.tmdbId, manageButton.dataset.tmdbType); return; }
                
                const forceButton = e.target.closest('.force-firestore-btn');
                if (forceButton) { toggleForceFirestore(forceButton); return; }

                const copyLinksButton = e.target.closest('.copy-all-links-btn');
                if (copyLinksButton) {
                    copyLinksButton.textContent = 'Copiando...';
                    copyAllSeriesLinksToClipboard(copyLinksButton.dataset.tmdbId).finally(() => {
                        copyLinksButton.textContent = 'Copiar Links';
                    });
                }
            };

            ui.catalogList.addEventListener('click', universalClickListener);
            ui.reportResultsContainer.addEventListener('click', universalClickListener);
            
            ui.quickAddBtn.addEventListener('click', () => {
                const rawValue = ui.quickAddTmdbId.value.trim();
                const id = rawValue.replace(/\D/g, ''); 
                const type = ui.quickAddMediaType.value;
                if (!id) { alert('Por favor, insira um ID do TMDB válido.'); return; }
                prepareFormForEditing(id, type);
            });
            ui.quickAddTmdbId.addEventListener('keypress', (e) => { if (e.key === 'Enter') ui.quickAddBtn.click(); });

            ui.mediaForm.addEventListener('submit', handleMediaFormSubmit);
            ui.cancelEditBtn.addEventListener('click', resetForm);
            ui.addMovieUrlBtn.addEventListener('click', () => addMovieResolutionUI());
            
            ui.movieUrlsList.addEventListener('click', (e) => {
                if (e.target.closest('.remove-btn')) {
                    const confirmation = confirm('Tem certeza que deseja remover esta resolução?');
                    if (confirmation) {
                        e.target.closest('.p-3').remove();
                    }
                }
            });

            ui.seasonSelector.addEventListener('change', async (e) => {
                const seriesId = ui.tmdbIdInput.value;
                const docRef = doc(firestore, "media", seriesId.toString());
                const docSnap = await getDoc(docRef);
                const firestoreData = docSnap.exists() ? docSnap.data() : {};
                await loadEpisodesForSeason(seriesId, e.target.value, firestoreData);
            });
            
            ui.copyAllLinksFormBtn.addEventListener('click', () => {
                const seriesId = ui.tmdbIdInput.value;
                const button = ui.copyAllLinksFormBtn;
                if (seriesId) {
                    button.textContent = 'Copiando...';
                    copyAllSeriesLinksToClipboard(seriesId).finally(() => { button.textContent = 'Copiar Todos os Links'; });
                }
            });

            ui.episodesList.addEventListener('click', (e) => {
                const removeBtn = e.target.closest('.remove-episode-btn');
                if (removeBtn) {
                    const episodeRow = removeBtn.closest('.p-3');
                    const urlInput = episodeRow.querySelector('.episode-url');
                    const thumbInput = episodeRow.querySelector('.episode-thumbnail-url');
                    if (urlInput) urlInput.value = '';
                    if (thumbInput) thumbInput.value = '';
                }
            });

            ui.bulkImportBtn.addEventListener('click', () => {
                const isHidden = ui.bulkImportTextarea.classList.contains('hidden');
                if (isHidden) {
                    ui.bulkImportTextarea.classList.remove('hidden');
                    ui.invertOrderBtn.classList.remove('hidden');
                    ui.bulkImportTextarea.focus();
                    ui.bulkImportBtn.textContent = 'Aplicar Links';
                } else {
                    handleBulkImport();
                    ui.bulkImportTextarea.classList.add('hidden');
                    ui.invertOrderBtn.classList.add('hidden');
                    ui.bulkImportBtn.textContent = 'Importar em Massa';
                }
            });

            ui.invertOrderBtn.addEventListener('click', handleInvertOrder);

            ui.reportTabs.addEventListener('click', (e) => {
                const button = e.target.closest('.report-btn');
                if (button) {
                    document.querySelectorAll('.report-btn').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    displayReportResults(button.dataset.reportType);
                }
            });

            ui.forceFirestoreAllMoviesBtn.addEventListener('click', forceFirestoreForAllLinkedMovies);
            ui.downloadMoviesBtn.addEventListener('click', downloadAllMoviesAsTxt);
            ui.downloadSeriesBtn.addEventListener('click', downloadAllSeriesAsTxt);
        });
    </script>
</body>
</html>
}